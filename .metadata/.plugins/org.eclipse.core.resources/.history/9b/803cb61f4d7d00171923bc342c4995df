/*
 * LinkedList.h
 *
 *  Created on: Aug 8, 2015
 *      Author: Hazard Nguyen
 */

#ifndef LINKEDLIST_H_
#define LINKEDLIST_H_

#include <iostream>
using namespace std;
template <class T>
	struct Node{
		T data;
		Node *next;
		Node(){
			this->data = NULL;
			this->next = NULL;
		}
		Node(T value){
			this->data = value;
			this->next = NULL;
		}
		Node(const Node<T>& copy){
			this->data = copy.data;
			this->next = copy.next;
		}
		~Node(){
			delete next;
			this->next = NULL;
		}
		Node<T>& operator=(const Node<T>& obj){
			this->data = obj.data;
			this->next = obj.next;
			return this;
		}
	};
template <class T>
class LinkedList{
private:

	Node<T> *head;
	Node<T> *tail;
public:
	LinkedList();
	LinkedList(Node<T>*);
	LinkedList(const LinkedList<T>&);
	void insertTail(T);
	void insertHead(T);

	LinkedList<T>& begin();
	LinkedList<T>& end();
	LinkedList& operator=(const LinkedList&);
	//void print();
	~LinkedList();
	friend ostream& operator<<(ostream&,const LinkedList<T>&);
	friend Node<T>& iterator;
private:
	void addNode(Node<T> data);

};

template <class T>
LinkedList<T>::LinkedList(){
	this->head	 	= new Node<T>();
	this->tail		= new Node<T>();
	//this->iterator	= NULL;
}
template <class T>
LinkedList<T>::LinkedList(Node<T>* newNode){
	this->head = newNode;
	this->tail = newNode;

}

template <class T>
LinkedList<T>::LinkedList(const LinkedList<T>& obj):head(NULL),tail(NULL){
	Node<T>* cur = obj.head;
	while(cur){
		this->addNode(cur);
		cur=cur->next;
	}


}

template <class T>
void LinkedList<T>::insertTail(T val){
	Node<T>* data = new Node<T>(val);
	if(this->tail==NULL){
		data->next = this->tail;
		this->head = data;
		this->tail = data;
	}
	tail->next 	= data;
	tail 		= tail->next;
}
template <class T>
void LinkedList<T>::insertHead(T val){
	Node<T>* data = new Node<T>(val);

	data->next = this->head;
	this->head = data;
	if(this->head->next==NULL){
		this->tail=data;
	}
}
template <class T>
LinkedList<T>& LinkedList<T>::begin(){
	return this->head;
}
template <class T>
LinkedList<T>& LinkedList<T>::end(){
	return this->tail;
}
template <class T>
void LinkedList<T>::addNode(Node<T> data){
	if(this->tail==NULL){
			data->next = this->tail;
			this->head = data;
			this->tail = data;
		}
		this->tail->next 	= data;
		this->tail 			= this->tail->next;
}

template <class T>
LinkedList<T>& LinkedList<T>::operator=(const LinkedList<T>& other){
	this->head = other.head;
	this->tail = other.tail;
	return this;
}
template <class T>
ostream& operator<<(ostream& out,const LinkedList<T>& list){

	while(cur){
		out<<cur->data<<" ";
		cur = cur->next;
	}
	out<<endl;
	return out;
}
template <class T>
LinkedList<T>::~LinkedList(){

	delete(this->head);
	delete(this->tail);
	this->head = NULL;
	this->tail = NULL;

}

#endif /* LINKEDLIST_H_ */
